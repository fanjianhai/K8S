

## 0. Docker容器化封装应用程序的优缺点

### 优点

- Docker引擎统一了基础设施环境--docker环境
  - 硬件的配置
  - 操作系统的版本
  - 运行时环境的异构
- Docker引擎统一了程序打包（装箱）方式--docker镜像
  - java程序
  - python程序
  - go程序
  - ...
- Docker引擎统一了程序部署（运行）方式--docker容器
  - java -jar  ... --> docker run ...
  - python manage.py runserver ... --> docker run ...
  - npm run dev ... --> docker run ...
  - ...

### 缺点

- 单机使用，无法有效集群（集群方式复杂）
- 随着容器数量的上升，管理成本攀升
- 没有有效的容灾、自愈机制
- 没有预设编排模板，无法实现快速、大规模容器调度
- 没有统一的配置管理中心工具
- 没有容器生命周期的管理工具
- 没有图形化运维管理工具
- ...

## 1. kubernetes的背景

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201112174509967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)

- Mesos 是一款 基于Apache协议的分布式资源管理框架， 2019-05  它最大的使用者Twitter开始由Mesos转向Kubernetes
- Docker Swarm 2019-07 阿里云宣布  Docker Swarm 剔除
- Google 10年前的容器化基础架构 borg，随着go语言的诞生，基于borg，不断改进，推出了Kubernetes, **在2014年6月开源**, 后经Go语言重写并捐献给**CNCF云原生基金会**开源
- Docker：**码头工人---> 集装箱**
- K8s：**舵手 ---> 货轮运输**    

- Kubernetes特点：
  - 轻量级：消耗资源小
  - 开源
  - 弹性伸缩
  - 负载均衡：IPVS
- kubernetes优势：
  - 自动装箱，水平扩展，自我修复
  - 服务发现和负载均衡
  - 自动发布（默认滚动发布模式）和回滚
  - 集中化配置管理和密钥管理
  - 存储编排
  - 任务批处理运行
  - ...

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201027110755684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)

## 2. Kubernetes组件说明

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201027142328908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)

- **etcd**保存了整个集群的状态
- **apiserver**提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；
- **controller manager** 负责维护集群的状态， 比如故障检测、自动扩展、滚动更新等；
- **scheduler**负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；
- **kubelet**负责维护容器的声明周期，同时也是负责Volume（CVI）和网络（CNI）的管理；
- **kube-proxy**负责为Service提供cluster内部的服务发现和负载均衡；
- **Container runtime**负责镜像管理以及Pod和容器的真正运行（CRI）

###2.1. 核心组件

- 配置存储中心--> etcd服务
- 主控（master）节点
  - kube-apiserver服务（k8s的大脑）
    - 提供了集群管理的REST API 接口（包括鉴权、数据校验及集群状态变更）
    - 负责其他模块之间的数据交互，承担通信枢纽功能
    - 是资源配额控制的入口
    - 提供完备的集群安全机制
  - kube-controller-manager服务
    - 由一系列控制器组成，通过apiserver监控整个集群的状态，并确保集群处于预期的工作状态
    - Node Controller
    - Deployment Controller
    - Service Controller
    - Volume Controller
    - Endpoint Controller
    - Garbage Controller
    - Namespace Controller
    - Job Controller
    - Resource quta Controller
    - ...
  - kube-scheduler服务
    - 主要功能是接受调度pod到适合的运算节点上
    - 预算策略（predict）
    - 有限策略（priorities）
- 运算（node）节点
  - kube-kubelet服务
    - 简单地说，kubelet的主要功能就是定时从某个地方获取节点上pod的期望状态（运行什么容器、运行的副本数量、网络或者存储如何配置等等），并调用对应的容器平台接口达到这个状态
    - 定时汇报当前结点的状态给apiserver，以供调度的时候使用
    - 镜像和容器的清理工作，保证结点上镜像不会栈满磁盘空间，退出的容器不会占用太多资源
  - kube-proxy服务
    - 是k8s在每个节点上运行网络代理，service资源的载体
    - 建立了pod网络和集群网络的关系（clusterip -> podip）
    - 常用的三种流量调度模式：
      - Userspace（废弃）
      - Iptables（濒临废弃）
      - IPvs（推荐）
    - 负责建立和删除包括更新调度规则、通知apiserver自己的更新，或者从apiserver那里获取其他的kube-proxy的调度规则变化来更新自己的



### 2.2.  CLI客户端

- kubectl



### 2.3.  核心附件

- CNI网络插件 --> flannel/calico
- 服务发现用插件 --> coredns
- 服务暴露用插件 --> traefik
- GUI管理插件 -- dashboard





## 3. Kubernetes对象

### 3.1. 资源对象Pod

#### 概念

Pod是在Kubernetes集群中运行部署应用或服务最小单元，设计理念是支持多个容器在一个Pod中共享`网络地址`和`文件系统`可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。

#### 使用方式

- 一个Pod中运行一个容器。可以把Pod想象成是单个容器的封装，Kubernetes管理的是Pod而不是直接管理容器

- 在一个Pod中同时运行多个容器。一个Pod中同时封装几个需要紧密耦合互相协作的容器，之间共享资源。
- 同一个Pod中的容器会自动的分配到同一个node上。同一个Pod中的容器共享资源、网络环境和依赖，它们总是同时调度。
- 一个Pod中同时运行多个容器是一种比较高级的用法。有当你的容器需要紧密配合协作的时候才考虑这种模式。例如：你有一个容器作为web服务运行，需要用到共享的volume，有另一个“sidecar” 容器来从远端获取资源更新这些文件

#### Pod中可以共享资源：网络和存储

- **网络：**每个Pod都会被分配一个唯一的IP地址。Pod中的所有容器共享网络空间，包括IP地址和端口
- **存储：**可以为Pod指定多个共享的Volume。Pod中的所有容器都可以访问共享的volume。（Volume也可以持久化Pod中的存储资源，以防容器重启后文件丢失）
- Pod不会自愈，有问题就会被干掉再起一个；Pod下的容器重启，不代表Pod会重启。虽然可以直接使用Pod，但是在Kubernetes中通常是使用Controller来管理Pod的

#### Pod和Controller

- Controller可以创建和管理多个Pod，提供副本管理，滚动升级和集群级别的自愈能力。例如，如果一个Node故障，Controller就能自动将该节点上的Pod调度到其他健康的Node上

#### Pod Templates

- Pod模板是包含了其他object的Pod定义，例如Replication Controllers，Jobs 和DaemonSets。Controller根据Pod模板来创建实际的Pod。

#### Pod删除

- 默认优雅删除

  1. 用户发送删除Pod的命令，默认优雅删除的时期是30秒
  2. 在Pod超过该优雅删除期限后，API server 就会更新Pod的状态为 “dead”
  3. 在客户端命令行上显示的Pod状态为“terminating” 状态时，开始停止Pod进程；
  4. 跟第三步同时，当kubelet发现pod被标记为“terminating”状态时，开始停止pod进程；
  5. 如果在pod中定义了preStop hook，在停止pod前会被调用。如果在优雅删除期限过期后，preStop依然在运行，第二步会再增加2秒的优雅时间

  6.  向Pod中的进程发送TERM信号；
  7. 跟第三步同时，该Pod将从该service的端点列表中删除，不再是replication controller的一部分， 关闭慢的pod将继续处理load balance转发的流量；
  8. 过了优雅周期后，将想Pod中依然运行的进程发送SIGKILL信号而杀掉进程
  9. kubelet会在API server中完成Pod的删除，通过将优雅周期设置为0（立即删除）， Pod在api中消失，并且在客户端也不可见。
- 支持强制删除
  1. 强制删除是通过在集群和etcd中将其定义为删除状态。API server不会等待该pod所运行在结点上的kubelet确认，就会立即将改pod从API server中移出，这时， 在节点上的pod会立即设置为terminating状态，不过在被强制删除之前依然有一小段优雅删除周期

#### Pod的init容器

`和普通容器的差别`

- init 容器总是运行到成功完成为止。
- 一个Pod指定了多个init容器，那些容器会按顺序一次运行一个，每个init容器必须运行成功，下一个才能够运行。
- 如果Pod的init容器失败，Kubernetes会不断的重启该Pod，直到init容器成功为止。除非Pod对应的restartPolicy 为 Never
- 而且init容器不支持Readiness，因为它们必须在Pod就绪之前运行完成

#### Pod安全策略

`由设置和策略组成用以控制Pod访问`

- **基于布尔控制：**这种类型的字段默认为最严格限制的值
- **基于被允许的值集合控制：**这种类型的字段会与这组值进行对比，以确认值被允许。
- **基于策略控制：**设置通过一种策略提供的机制来生成该值，这种机制能够确保指定的值落在被允许的这组值中。

#### Pod生命周期

`Pod状态（PodStatus对象）`

- Pod 的status将信息保存在PodStatus中的phase（相位）字段。`Pod 相位的数量和含义是严格指定的。除了文本文档中列巨的状态外，不应该在假定Pod有其他的phase值。`
- phase值
  - **挂起(Pending):** Pod 已被Kubernetes系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度Pod的时间和通过网络下载镜像的时间，这可能需要花点时间；
  - **运行中（Running）：**该Pod已经绑定到了一个节点上，Pod中所有的容器都已被创建。至少有一个容器正在运行，或者正好处于启动或者重启状态
  - **成功（Succeed）：**Pod中的所有容器都被成功终止，并且不会再重启
  - **失败（Failed）：**Pod中的所有容器都已经终止了，并且至少有一个容器是因为失败终止，也就是说，容器以非0状态退出或者被系统终止。
  - **未知（Unknown）：**因为某些原因无法取得Pod的状态，通常是因为与Pod所在的主机通信失败
- 容器探针
  - ExecAction：在容器内执行指定命令。如果命令退出时返回码为0则认为诊断成功 TCPSocketAction：对指定端口上的容器IP地址进行TCP检查。如果端口打开，则诊断被认为是成功的。
  - HTTPGetAction： 对指定端口和路径上的容器IP地址执行Http Get请求。如果相应的状态码大于等于200 且小于400， 则诊断被人为师成功的。
  - 探针结果
    - 成功：容器通过了诊断。失败：容器未通过诊断
    - 未知：诊断失败，因此不会才去任何行动。
  - 探针类型
    - 存活（liveness）探针
      - 指示容器是否在运行。如果存活探测失败，则kubelet会杀死容器
    - 就绪（readiness）探针
      - 指示容器是否准备好服务请求。如果就绪探测失败，断点控制器将从与Pod匹配的所有Service的端点中删除该Pod的IP地址

#### Pod中断

- 非自愿中断
  - 后端节点物理机的硬件故障
  - 集群管理员错误地删除虚拟机（实例）
  - 云提供商或管理程序故障使虚拟机消失
  - 内核恐慌（kernel panic）
  - 节点由于集群网络分区而从集群中消失
  - 由于节点资源不足而将容器逐出
- 自愿中断
  - 删除管理该pod的Deployment或其他控制器
  - 更新了Deployment的pod模板导致pod重启
  - 直接删除pod（意外删除）
- PDB（PodDisruptionBudget对象）
  - PDB将限制在同一时间自愿中断的复制应用程序中宕机的Pod的数量。例如，基于定额的应用程序希望确保运行的副本数量永远不会低于仲裁所需的数量。Web前端可能希望确保提供负载的副本的数量永远不会低于总数的某个百分比。

#### 为什么单个pod中不应该同时运行一个应用的多个实例？

#### 为什么不直接在一个容器中运行多个应用程序？

- 透明。让pod中的容器对基础设施可见，以便基础设施能够为这些容器提供服务，例如进程管理和资源监控，这可以为用户带来极大的便利。
- 解耦软件依赖。每个容器都可以进行版本管理，独立的编译和发布。未来Kubernetes甚至可能支持单个容器的在线升级。
- 使用方便。 用户不必运行自己的进程管理器， 还要担心错误信号传播等。
- 效率。因为由基础架构提供更多的职责，所以容器可以变得更加轻量级。

### 3.2. 部署（Deployment）

#### 概念

- 部署表示用户对kubernetes集群的一次更新操作，比RC更大，如部署可以标示RC减到0再增加到制定Pad数的复合操作
- 为Pod和Replica Set（下一代Replication Controller）提供声明式更新。

#### Demo

创建一个Deployment Spec

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201028152306898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)

### 3.3. 后台支撑服务集（DaemonSet）

- 典型的后台支撑服务包括：存储， 日志和监控等在每个节点上支持kubernetes集群运行的服务

### 3.4. 有状态的服务集（PetSet）

- PetSet是用来控制有状态服务（RC控制无状态的Pod）， PetSet中的每个Pod的名字都是事先确定的，不能更改。PetSet中Pod的名字的作用是关联与该Pod对应的状态。一般会有本地存储用以保存状态
- 特点：stateful、 宠物（pet）、 有名（hiving name）、不可丢弃（non-disposable）
- 如：ZK、MySql、etcd等需要用PetSet管理。

### 3.5. 副本集（Replica Set， RS）

- RS是新一代RC，提供同样的高可用能力，能支持更多种类的匹配模式

### 3.6. 副本控制器（Replication Controller RC）

- 通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。少于指定数目的Pod脚本，RC就会启动运行新的；多余指定数目，RC就会杀死多余的Pod副本

### 3.7. 集群联邦（Federation）

- Kubernetes的设计定位是单一集群在同一个Zone（跨主机同可用区）。而联合集群服务就是为提供跨Region（跨同地区可用区）跨服务商Kubernetes集群服务而设计的

### 3.8. 任务Job

- Job是Kubernetes用来控制批处理型任务的API对象。和service区别是运行有头有尾，任务成功完成就自动退出了。

### 3.9 CronJob

### 3.10. HorizontalPodAutoscaling

## 4. 架构详解

![](http://noah-pic.oss-cn-chengdu.aliyuncs.com/pic/20200416/094722757.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081911593913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)

## 5. 核心概念

### 5.1. Pod和Pod控制器

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201112182339306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)

### 5.2. Name和Namespace

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201112182835703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)

### 5.3. Label和Label选择器

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201112183523650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)

### 5.4. Service和Ingress

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201112195239841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



